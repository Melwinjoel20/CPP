import boto3
from django.shortcuts import render, redirect
from django.conf import settings
from django.contrib import messages
from django.contrib.messages import get_messages
from botocore.exceptions import ClientError
from easycart_rate_limiter import check_rate_limit
import hmac
import hashlib
import base64



# Home / Base view
def base(request):
    return render(request, 'base.html')

def home(request):
    
    return render(request, 'home.html')

# ==========================================================
# Helpers
# ==========================================================

def get_cognito_client():
    return boto3.client(
        "cognito-idp",
        region_name=settings.COGNITO["region"],
    )


def clear_messages(request):
    storage = get_messages(request)
    for _ in storage:
        # iterating consumes them
        pass


def get_secret_hash(username: str) -> str:
    """
    Compute SECRET_HASH for Cognito app clients that have a secret.
    SECRET_HASH = base64(HMAC_SHA256(client_secret, username + client_id))
    """
    client_id = settings.COGNITO["app_client_id"]
    client_secret = settings.COGNITO["app_client_secret"]

    msg = username + client_id
    dig = hmac.new(
        client_secret.encode("utf-8"),
        msg=msg.encode("utf-8"),
        digestmod=hashlib.sha256,
    ).digest()
    return base64.b64encode(dig).decode("utf-8")


# ==========================================================
# LOGIN
# ==========================================================

def login_view(request):
    if request.method == "POST":
        email = request.POST.get("email", "").strip()
        password = request.POST.get("password", "").strip()

        if not email or not password:
            messages.error(request, "Please enter email and password.")
            return redirect("login")

        # Per-user rate limit
        key = f"login:{email}"

        # ‚ùó No silent fallback: if import missing, app errors (correct)
        allowed = check_rate_limit(
            key,
            limit=settings.RATE_LIMIT_LOGIN_LIMIT,
            window=settings.RATE_LIMIT_LOGIN_WINDOW,
        )

        if not allowed:
            messages.error(
                request,
                "Too many failed login attempts. Try again in 1 minute."
            )
            return redirect("login")

        client = get_cognito_client()

        try:
            # ADMIN_USER_PASSWORD_AUTH + SECRET_HASH
            auth_response = client.admin_initiate_auth(
                UserPoolId=settings.COGNITO["user_pool_id"],
                ClientId=settings.COGNITO["app_client_id"],
                AuthFlow="ADMIN_USER_PASSWORD_AUTH",
                AuthParameters={
                    "USERNAME": email,
                    "PASSWORD": password,
                    "SECRET_HASH": get_secret_hash(email),
                },
            )

        except client.exceptions.NotAuthorizedException:
            messages.error(request, "Incorrect email or password.")
            return redirect("login")

        except client.exceptions.UserNotFoundException:
            messages.error(request, "No account found with this email.")
            return redirect("login")

        except client.exceptions.UserNotConfirmedException:
            if getattr(settings, "DEV_MODE", False):
                messages.warning(request, "Email verification skipped (DEV mode).")
                try:
                    client.admin_confirm_sign_up(
                        UserPoolId=settings.COGNITO["user_pool_id"],
                        Username=email,
                    )
                    auth_response = client.admin_initiate_auth(
                        UserPoolId=settings.COGNITO["user_pool_id"],
                        ClientId=settings.COGNITO["app_client_id"],
                        AuthFlow="ADMIN_USER_PASSWORD_AUTH",
                        AuthParameters={
                            "USERNAME": email,
                            "PASSWORD": password,
                            "SECRET_HASH": get_secret_hash(email),
                        },
                    )
                except Exception:
                    messages.error(request, "Incorrect email or password.")
                    return redirect("login")
            else:
                messages.error(request, "Please verify your email before logging in.")
                return redirect("login")

        except ClientError as e:
            messages.error(request, f"Login failed: {e.response['Error']['Message']}")
            return redirect("login")

        except Exception as e:
            messages.error(request, f"Login failed: {str(e)}")
            return redirect("login")

        # üéâ If we reach here, password is correct and auth succeeded
        tokens = auth_response.get("AuthenticationResult", {})
        access_token = tokens.get("AccessToken")
        id_token = tokens.get("IdToken")

        if access_token:
            request.session["cognito_access_token"] = access_token
            print("ACCESS TOKEN:", access_token)

        if id_token:
            request.session["cognito_id_token"] = id_token
            print("ID TOKEN:", id_token)

        # Fetch user details
        try:
            user = client.admin_get_user(
                UserPoolId=settings.COGNITO["user_pool_id"],
                Username=email,
            )
        except Exception as e:
            messages.error(request, f"Failed to fetch user info: {e}")
            return redirect("login")

        full_name = None
        email_verified = False
        for attr in user.get("UserAttributes", []):
            if attr["Name"] == "name":
                full_name = attr["Value"]
            elif attr["Name"] == "email_verified":
                email_verified = (attr["Value"] == "true")

        if not getattr(settings, "DEV_MODE", False) and not email_verified:
            messages.error(request, "Please verify your email before logging in.")
            return redirect("login")

        request.session["user_email"] = email
        request.session["user_name"] = full_name
        request.session["user_id"] = email

        messages.success(request, f"Welcome, {full_name or email}!")
        return redirect("home")

    # GET
    return render(request, "login.html")


# ==========================================================
# LOGOUT
# ==========================================================

def logout_view(request):
    request.session.flush()
    clear_messages(request)
    messages.success(request, "You have been logged out.")
    return redirect("login")


# ==========================================================
# REGISTER
# ==========================================================

def register(request):
    if request.method == "POST":
        name = request.POST.get("name", "").strip()
        email = request.POST.get("email", "").strip()
        password = request.POST.get("password")

        if not (name and email and password):
            messages.error(request, "Please fill in all fields.")
            return redirect("register")

        client = get_cognito_client()

        try:
            # Sign up ‚Äì includes SECRET_HASH because client has secret
            resp = client.sign_up(
                ClientId=settings.COGNITO["app_client_id"],
                SecretHash=get_secret_hash(email),
                Username=email,
                Password=password,
                UserAttributes=[
                    {"Name": "email", "Value": email},
                    {"Name": "name", "Value": name},
                ],
            )
            print("SIGN UP RESP:", resp)

            # DEV: auto-confirm
            if getattr(settings, "DEV_MODE", False):
                try:
                    client.admin_confirm_sign_up(
                        UserPoolId=settings.COGNITO["user_pool_id"],
                        Username=email,
                    )
                    messages.success(
                        request,
                        "Account created (DEV MODE auto-confirmed). You can now login."
                    )
                    return redirect("login")
                except Exception as e:
                    messages.warning(request, f"Auto-confirm skipped: {e}")
                    # fall through to OTP flow

            # Normal: send OTP and redirect to verify page
            request.session["pending_email"] = email
            messages.success(
                request,
                "Account created! We've sent a verification code to your email. "
                "Enter it below to activate your account."
            )
            return redirect("verify_otp")

        except client.exceptions.UsernameExistsException:
            messages.error(request, "This email already exists.")
            return redirect("register")

        except client.exceptions.InvalidPasswordException:
            messages.error(
                request,
                "Password must contain uppercase, lowercase, number, and symbol."
            )
            return redirect("register")

        except ClientError as e:
            messages.error(request, f"Error: {e.response['Error']['Message']}")
            return redirect("register")

        except Exception as e:
            messages.error(request, f"Error: {str(e)}")
            return redirect("register")

    # GET
    return render(request, "register.html")


# ==========================================================
# VERIFY OTP (CONFIRM SIGNUP)
# ==========================================================

def verify_otp(request):
    email = request.session.get("pending_email")

    if not email:
        messages.error(request, "No pending registration found. Please register first.")
        return redirect("register")

    client = get_cognito_client()

    if request.method == "POST":
        code = request.POST.get("code", "").strip()

        if not code:
            messages.error(request, "Please enter the verification code.")
            return render(request, "verify_otp.html", {"email": email})

        try:
            client.confirm_sign_up(
                ClientId=settings.COGNITO["app_client_id"],
                SecretHash=get_secret_hash(email),
                Username=email,
                ConfirmationCode=code,
            )

        except client.exceptions.CodeMismatchException:
            messages.error(request, "Invalid verification code. Please try again.")
            return render(request, "verify_otp.html", {"email": email})

        except client.exceptions.ExpiredCodeException:
            messages.error(request, "Verification code expired. Please request a new one.")
            return render(request, "verify_otp.html", {"email": email})

        except ClientError as e:
            messages.error(
                request,
                f"Could not verify your account: {e.response['Error']['Message']}"
            )
            return render(request, "verify_otp.html", {"email": email})

        except Exception:
            messages.error(request, "Could not verify your account. Please try again.")
            return render(request, "verify_otp.html", {"email": email})

        # Success
        request.session.pop("pending_email", None)
        messages.success(request, "Your email is verified. You can now log in.")
        return redirect("login")

    # GET
    return render(request, "verify_otp.html", {"email": email})


# ==========================================================
# FORGOT PASSWORD
# ==========================================================

def cognito_forgot_password(username: str):
    client = get_cognito_client()
    try:
        return client.forgot_password(
            ClientId=settings.COGNITO["app_client_id"],
            Username=username,
            SecretHash=get_secret_hash(username),
        )
    except ClientError as e:
        return {"error": e.response["Error"]["Message"]}
    except Exception as e:
        return {"error": str(e)}


def forgot_password(request):
    if request.method == "POST":
        username = request.POST.get("username", "").strip()

        if not username:
            messages.error(request, "Please enter your email.")
            return redirect("forgot_password")

        res = cognito_forgot_password(username)
        print("FORGOT PASSWORD RESPONSE:", res)
        if "error" in res:
            messages.error(request, res["error"])
            return redirect("forgot_password")

        request.session["reset_username"] = username
        messages.success(request, "OTP sent to your email.")
        return redirect("reset_password")
        

    return render(request, "forgot_password.html")
    print("FORGOT PASSWORD RESPONSE:", res)


# ==========================================================
# RESET PASSWORD (CONFIRM FORGOT PASSWORD)
# ==========================================================

def cognito_confirm_new_password(username: str, code: str, new_password: str):
    client = get_cognito_client()
    try:
        return client.confirm_forgot_password(
            ClientId=settings.COGNITO["app_client_id"],
            Username=username,
            ConfirmationCode=code,
            Password=new_password,
            SecretHash=get_secret_hash(username),
        )
    except ClientError as e:
        return {"error": e.response["Error"]["Message"]}
    except Exception as e:
        return {"error": str(e)}


def reset_password(request):
    username = request.session.get("reset_username")

    if not username:
        messages.error(
            request,
            "No password reset request found. Please request a reset again."
        )
        return redirect("forgot_password")

    if request.method == "POST":
        code = request.POST.get("code", "").strip()
        new_password = request.POST.get("password", "")

        if not code or not new_password:
            messages.error(request, "Please fill in all fields.")
            return redirect("reset_password")

        res = cognito_confirm_new_password(username, code, new_password)

        if "error" in res:
            messages.error(request, res["error"])
            return redirect("reset_password")

        request.session.pop("reset_username", None)
        messages.success(request, "Password reset successful! You can now login.")
        return redirect("login")

    return render(request, "reset_password.html")

def get_all_categories():
    return ["Phones", "Laptops", "Accessories"]  # Can be replaced with auto-detection later


def generate_presigned_image(key):
    s3 = boto3.client("s3", region_name=settings.S3_REGION)
    return s3.generate_presigned_url(
        ClientMethod="get_object",
        Params={"Bucket": settings.S3_BUCKET, "Key": key},
        ExpiresIn=3600  # 1 hour
    )




def generate_presigned_image_url(key: str):
    s3 = boto3.client("s3", region_name=settings.S3_REGION)

    try:
        return s3.generate_presigned_url(
            ClientMethod="get_object",
            Params={"Bucket": settings.S3_BUCKET, "Key": key},
            ExpiresIn=3600,   # 1 hour
        )
    except Exception as e:
        print("Error generating image URL:", e)
        return None


def products(request, category=None):
    categories = get_all_categories()  
    # Example: ["Accessories", "Laptops", "Phones"]

    # ---------------------------
    # üîç SEARCH LOGIC (NEW PART)
    # ---------------------------
    search = request.GET.get("search", "").strip().lower()

    if search:
        keyword_map = {
            "Accessories": ["accessory", "accessories", "earphone", "earphones", "headphones", "charger"],
            "Laptops": ["laptop", "laptops", "notebook", "macbook"],
            "Phones": ["phone", "phones", "mobile", "smartphone"],
        }

        matched_category = None

        for table_name, words in keyword_map.items():
            if any(w in search for w in words):
                matched_category = table_name
                break

        # If search matched ‚Üí override the category and load that table
        if matched_category:
            category = matched_category
        else:
            category = None   # show ALL products

    # ---------------------------
    # EXISTING CODE CONTINUES
    # ---------------------------

    dynamodb = boto3.resource("dynamodb", region_name=settings.COGNITO["region"])
    items = []

    if category:
        if category not in categories:
            messages.error(request, "Invalid category selected.")
            return redirect("products")

        table = dynamodb.Table(category)
        response = table.scan()
        items = response.get("Items", [])
    else:
        for cat in categories:
            table = dynamodb.Table(cat)
            response = table.scan()
            items.extend(response.get("Items", []))

    for item in items:
        key = item.get("image")
        item["image_url"] = generate_presigned_image_url(key) if key else None

    lambda_cfg = settings.COGNITO["lambda_cart_endpoints"]

    return render(request, "products.html", {
        "products": items,
        "category": category,
        "categories": categories,
        "ADD_TO_CART_URL": lambda_cfg["add_to_cart"],
        "VIEW_CART_URL": lambda_cfg["view_cart"],
        "REMOVE_ITEM_URL": lambda_cfg["remove_cart_item"],
    })

def view_cart(request):
    lambda_cfg = settings.COGNITO["lambda_cart_endpoints"]

    return render(request, "view_cart.html", {
        "VIEW_CART_URL": lambda_cfg["view_cart"],
        "REMOVE_ITEM_URL": lambda_cfg["remove_cart_item"],
    })

def checkout(request):
    lambda_cfg = settings.COGNITO["lambda_cart_endpoints"]

    return render(request, "checkout.html", {
        "VIEW_CART_URL": lambda_cfg["view_cart"],
        "PLACE_ORDER_URL": lambda_cfg["place_order"],
    })

def order_confirmation(request):
    order_id = request.GET.get("id")

    return render(request, "order_confirmation.html", {
        "order_id": order_id
    })


